{
  "subtasks": [
    {
      "id": "1",
      "description": "Create a new module `eab/dwt_explain.py` that contains the core logic for the DWT stream explain feature. This module should:\n\n1. **ELF source-line enrichment function**: Given an address and an ELF file path, resolve the source file and line number using pyelftools (or addr2line as fallback). Return a dict with keys like `source_file`, `line_number`, `function_name`. Follow the pattern used in `eab/dwt_profiler.py` for ELF/symbol handling.\n\n2. **Event capture function**: Given a list of armed DWT watchpoint descriptors and a duration in seconds, read the JSONL event stream for that duration and return a list of event dicts. Reuse the existing JSONL event format from the DWT subsystem.\n\n3. **Event enrichment function**: Take a list of raw JSONL event dicts and an ELF path, call the source-line resolver for each event's address, and return enriched event dicts that include `source_file`, `line_number`, `function_name` alongside the original event fields.\n\n4. **Prompt formatting function**: Take enriched events and produce a structured prompt string suitable for an LLM. The prompt should include a summary of captured events, source context for each event, and a list of suggested follow-up watchpoints (symbols referenced near the hit locations). Return a dict with keys `events`, `source_context`, `ai_prompt`, and `suggested_watchpoints`.\n\n5. **Orchestrator function** `run_dwt_explain(symbols: list[str], duration_s: int, elf_path: str, device: str | None = None) -> dict`: Arms DWT watchpoints on the given symbols (reuse `eab/dwt_profiler.py` watchpoint arming logic), calls the capture function, enriches events, formats the prompt, and returns the full result dict.\n\nUse type hints on all function signatures. Use Google-style docstrings for all public functions. Raise `ValueError` for unknown symbols or invalid ELF paths. Group imports as stdlib, external, internal.\n\nAcceptance criteria: Module exists at `eab/dwt_explain.py`, all functions defined with proper signatures and docstrings, imports resolve correctly.",
      "files": [
        "eab/dwt_explain.py"
      ],
      "confidence": "UNCERTAIN \u2014 file analysis was not provided, so exact patterns in eab/dwt_profiler.py and JSONL event format are unknown. The implementer must read eab/dwt_profiler.py to discover the watchpoint arming API and event stream format."
    },
    {
      "id": "2",
      "description": "Add the `dwt_stream_explain` MCP tool to the existing MCP server in `eab/mcp_server.py`.\n\nThe file already contains an MCP server with 8 tools. Add a 9th tool following the exact same registration pattern used by the existing tools.\n\nTool specification:\n- Name: `dwt_stream_explain`\n- Parameters: `symbols: list[str]`, `duration_s: int`, `elf_path: str`\n- The tool handler should call `run_dwt_explain` from `eab/dwt_explain.py` (created in the previous subtask) and return its result.\n- Handle errors (ValueError, connection errors) the same way other tools in this file handle them.\n\nImport `run_dwt_explain` from `eab.dwt_explain` at the top of the file in the internal imports section.\n\nAcceptance criteria: The new tool is registered in the MCP server, callable with the three parameters, delegates to `run_dwt_explain`, and follows the same error handling and registration pattern as the existing 8 tools.",
      "files": [
        "eab/mcp_server.py"
      ],
      "confidence": "UNCERTAIN \u2014 file analysis was not provided, so the exact MCP tool registration pattern in eab/mcp_server.py is unknown. The implementer must read the file to discover how existing tools are registered."
    },
    {
      "id": "3",
      "description": "Add the `dwt explain` CLI subcommand to the existing CLI parser in `eab/cli/parser.py`.\n\nThe file already has a `dwt` subparser with subcommands `watch`, `halt`, `list`, and `clear`. Add a new `explain` subcommand following the same pattern.\n\nArguments for the `explain` subcommand:\n- `--device` (str, optional): Device identifier, e.g. `NRF5340_XXAA_APP`\n- `--symbols` (str, required): Comma-separated list of symbol names, e.g. `conn_interval,mtu_size`\n- `--elf` (str, required): Path to the ELF file\n- `--duration` (int, default 5): Capture duration in seconds\n- `--json` (flag): If set, output raw JSON; otherwise output the narrative text\n\nThe handler function should:\n1. Parse the comma-separated `--symbols` string into a list\n2. Call `run_dwt_explain` from `eab.dwt_explain` with the parsed arguments\n3. If `--json` is set, print the full result dict as JSON (use `json.dumps` with indent=2)\n4. Otherwise, print just the `ai_prompt` field from the result\n\nFollow the exact pattern used by the existing `dwt watch` subcommand for argument registration and handler wiring.\n\nAcceptance criteria: `eabctl dwt explain --symbols conn_interval --elf zephyr.elf --duration 10` invokes the handler; `--json` flag toggles output format; follows existing CLI patterns.",
      "files": [
        "eab/cli/parser.py"
      ],
      "confidence": "UNCERTAIN \u2014 file analysis was not provided, so exact CLI parser patterns and handler wiring in eab/cli/parser.py are unknown. The implementer must read the file."
    },
    {
      "id": "4",
      "description": "Create unit tests in `tests/unit/test_dwt_explain.py` for the DWT explain feature.\n\nTests should cover the following, using mocks for all external dependencies (DWT hardware access via pylink, ELF file reading, JSONL stream capture):\n\n1. **Test ELF source-line enrichment**: Mock pyelftools to return known source file/line for a given address. Verify the enrichment function returns the expected dict.\n\n2. **Test event capture with mock stream**: Mock the JSONL event source to yield a list of sample events. Verify the capture function returns them within the duration window.\n\n3. **Test event enrichment**: Provide raw events and a mock ELF resolver. Verify enriched events contain `source_file`, `line_number`, `function_name`.\n\n4. **Test prompt formatting**: Provide enriched events and verify the returned dict has keys `events`, `source_context`, `ai_prompt`, `suggested_watchpoints`. Verify `ai_prompt` is a non-empty string.\n\n5. **Test orchestrator `run_dwt_explain`**: Mock DWT watchpoint arming (from `eab.dwt_profiler`), mock JSONL capture, mock ELF resolution. Call `run_dwt_explain` with sample symbols and verify it returns a complete result dict.\n\n6. **Edge case \u2014 no events captured**: Mock the capture to return an empty list. Verify the function handles this gracefully (returns empty events list, prompt indicates no activity observed).\n\n7. **Edge case \u2014 unknown symbol**: Call with a symbol name that doesn't exist in the ELF. Verify a `ValueError` is raised.\n\nUse pytest. Use `unittest.mock.patch` and `unittest.mock.MagicMock` for mocking. Follow existing test patterns in `tests/unit/`. Use fixtures where appropriate.\n\nAcceptance criteria: All tests pass with `python3 -m pytest tests/unit/test_dwt_explain.py --tb=short -q`. No tests depend on hardware or real ELF files.",
      "files": [
        "tests/unit/test_dwt_explain.py"
      ],
      "confidence": "UNCERTAIN \u2014 file analysis was not provided, so existing test fixtures and patterns in tests/unit/ are unknown. The implementer should look at existing tests for mocking patterns."
    }
  ],
  "strategy": "execute",
  "deferred_work": ""
}