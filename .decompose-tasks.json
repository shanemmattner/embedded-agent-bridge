{
  "subtasks": [
    {
      "id": "1",
      "description": "Create new module `eab/thread_inspector.py`. Define a `ThreadInfo` dataclass with fields: name (str), state (str \u2014 one of RUNNING/READY/PENDING/SUSPENDED), priority (int), stack_base (int), stack_size (int), stack_used (int), stack_free (int). Include a `to_dict()` method for JSON serialization.\n\nImplement `inspect_threads(device: str, elf_path: str) -> list[ThreadInfo]` that: (1) generates a GDB Python script string that walks `_kernel.threads` linked list extracting thread name, `base.thread_state`, `base.prio`, `stack_info.start`, `stack_info.size`, and `stack_info.delta`, outputting results as JSON to stdout; (2) executes that script via the existing GDB one-shot bridge in `eab/gdb_bridge.py` (study its API for running GDB Python scripts against a device+ELF); (3) parses the JSON output into a list of ThreadInfo objects. Map Zephyr state flags to human-readable strings (RUNNING/READY/PENDING/SUSPENDED). Compute stack_free = stack_size - stack_used.\n\nFollow the GDB Python script pattern used in `eab/dwt_profiler.py` for how scripts are constructed and executed. Follow existing module conventions (imports, docstrings, error handling).\n\nAcceptance: module imports cleanly, ThreadInfo holds all required fields, inspect_threads returns parsed thread info from GDB output.",
      "files": [
        "eab/thread_inspector.py"
      ]
    },
    {
      "id": "2",
      "description": "Add CLI commands for thread inspection under `eabctl threads`. Study the existing CLI structure (likely under `eab/cli/` with Click or similar framework) to determine where to register the new command group.\n\nAdd subcommand `snapshot` with options: `--device` (required, device identifier e.g. NRF5340_XXAA_APP), `--elf` (required, path to ELF file), `--json` (flag, output as JSON array). When invoked, call `inspect_threads()` from `eab/thread_inspector.py` and print results. Without `--json`, print a human-readable table (thread name, state, priority, stack used/size, free). With `--json`, print a JSON array of ThreadInfo dicts.\n\nAdd subcommand `watch` with options: `--device` (required), `--elf` (required), `--interval` (default 5, seconds between polls), `--json` (flag). Repeatedly call `inspect_threads()` at the given interval, printing results each cycle. With `--json`, output one JSON object per line (JSONL format) with a timestamp field added. Without `--json`, clear and reprint the table each cycle. Handle KeyboardInterrupt gracefully to stop.\n\nRegister the new command group in the CLI entry point following existing patterns.\n\nAcceptance: `eabctl threads snapshot` and `eabctl threads watch` are callable, produce correct output formats, watch mode streams at the configured interval.",
      "files": [
        "eab/cli/threads.py"
      ]
    },
    {
      "id": "3",
      "description": "Add a new HIL regression step `stack_headroom_assert` in `eab/cli/regression/steps.py`. Study the existing step dispatch pattern in that file to understand how steps are registered and executed.\n\nThe step accepts YAML config with keys: `min_free_bytes` (int, required), `elf` (str, path to ELF), `device` (str, device identifier). When executed, it calls `inspect_threads(device, elf)` from `eab/thread_inspector.py`, then checks every returned ThreadInfo: if any thread's `stack_free` is less than `min_free_bytes`, the step fails with an error message listing the offending thread(s) (name, stack_free, min_free_bytes). If all threads meet the threshold, the step passes.\n\nFollow the existing step registration pattern exactly \u2014 match naming conventions, return types, and error reporting style of other steps in the file.\n\nAcceptance: `stack_headroom_assert` step is registered and dispatched correctly, fails when any thread is below threshold, passes when all threads have sufficient headroom.",
      "files": [
        "eab/cli/regression/steps.py"
      ]
    },
    {
      "id": "4",
      "description": "Add a new MCP tool `get_thread_state` in `eab/mcp_server.py`. Study the existing MCP tool registration pattern in that file.\n\nThe tool should accept parameters: `device` (str) and `elf_path` (str). It calls `inspect_threads(device, elf_path)` from `eab/thread_inspector.py` and returns the list of thread info as a JSON-serializable structure (list of dicts from ThreadInfo.to_dict()). Follow the existing tool registration pattern exactly \u2014 match naming, parameter declaration, return format, and error handling of other tools.\n\nAcceptance: `get_thread_state` tool is registered, callable through MCP, returns thread state data in the expected format.",
      "files": [
        "eab/mcp_server.py"
      ]
    },
    {
      "id": "5",
      "description": "Create unit tests in `tests/unit/test_thread_inspector.py`. Use pytest and follow existing test conventions in the tests/unit/ directory.\n\nTest cases to implement:\n\n1. **ThreadInfo dataclass**: Verify construction with all fields, verify `to_dict()` returns correct dict, verify `stack_free` is computed as `stack_size - stack_used`.\n\n2. **GDB output parsing**: Mock the GDB bridge execution (patch the function in `eab/gdb_bridge.py` that runs GDB scripts) to return simulated JSON output representing multiple Zephyr threads with varying states, priorities, and stack usage. Verify `inspect_threads()` returns correct ThreadInfo objects with all fields properly parsed. Test with thread states: RUNNING, READY, PENDING, SUSPENDED.\n\n3. **Stack headroom calculation**: Create ThreadInfo objects with known stack_size and stack_used values, verify stack_free is correct.\n\n4. **CLI snapshot JSON output**: Use Click's CliRunner (or equivalent test runner for the CLI framework) to invoke `threads snapshot --json` with mocked `inspect_threads`, verify output is valid JSON array with expected structure.\n\n5. **CLI watch JSONL output**: Mock `inspect_threads` and test that watch mode with `--json` produces valid JSONL (one JSON object per line with timestamp).\n\n6. **HIL step pass**: Mock `inspect_threads` to return threads all with stack_free > 256, verify `stack_headroom_assert` step passes with `min_free_bytes: 256`.\n\n7. **HIL step fail**: Mock `inspect_threads` to return one thread with stack_free = 100, verify `stack_headroom_assert` step fails with `min_free_bytes: 256` and error message includes the offending thread name.\n\n8. **GDB bridge error handling**: Mock GDB bridge to raise an exception, verify `inspect_threads` propagates it appropriately.\n\nAcceptance: All tests pass with `python3 -m pytest tests/unit/test_thread_inspector.py --tb=short -q`.",
      "files": [
        "tests/unit/test_thread_inspector.py"
      ]
    }
  ],
  "strategy": "execute",
  "deferred_work": ""
}