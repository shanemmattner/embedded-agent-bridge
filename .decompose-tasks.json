{
  "subtasks": [
    {
      "id": "1",
      "description": "Create a new module `eab/dwt_explain.py` containing the core business logic for the DWT stream explain feature. This module should be independent of both MCP and CLI entry points.\n\nThe module needs these components:\n\n1. **ELF enrichment function**: Given an ELF file path and a memory address, resolve the source file and line number. Use pyelftools (already a dependency used in `eab/dwt_profiler.py`) to perform addr2line-style resolution. Return a dict with keys like `file`, `line`, `function` (or None if unresolvable). Follow error handling patterns from `eab/dwt_profiler.py`.\n\n2. **Event enrichment function**: Take a list of raw JSONL DWT event dicts and an ELF path. For each event, look up the address field and attach source line info. Return the enriched list.\n\n3. **Prompt formatting function**: Take enriched events and format a structured LLM-friendly prompt string that describes what the firmware is doing. Include source context for each event. Also generate a list of suggested follow-up watchpoint symbols based on functions/variables referenced in the events.\n\n4. **Top-level orchestration function** `run_dwt_explain(symbols: list[str], duration_s: int, elf_path: str, device: str | None = None)` that:\n   - Arms DWT watchpoints on specified symbols (reuse logic from `eab/dwt_profiler.py`)\n   - Captures JSONL events for `duration_s` seconds\n   - Enriches events with ELF source info\n   - Formats the prompt\n   - Returns a TypedDict or dataclass with fields: `events` (list of enriched event dicts), `source_context` (dict mapping addresses to source info), `narrative` (str), `suggested_watchpoints` (list[str])\n\nUse type hints on all function signatures. Use Google-style docstrings for public functions. Raise ValueError for invalid inputs (empty symbols list, non-existent ELF path, duration <= 0). Follow import grouping conventions: stdlib, external, internal.",
      "files": [
        "eab/dwt_explain.py"
      ],
      "confidence": "UNCERTAIN - file analysis was not provided; paths are from the issue description. Implementer must read eab/dwt_profiler.py to understand DWT register access patterns, JSONL event format, and pylink usage before writing this module."
    },
    {
      "id": "2",
      "description": "Add the `dwt_stream_explain` MCP tool to `eab/mcp_server.py`.\n\nThe existing MCP server in this file already has 8 tools registered. Add a 9th tool following the exact same registration pattern used by existing tools.\n\nTool specification:\n- Name: `dwt_stream_explain`\n- Parameters: `symbols: list[str]`, `duration_s: int`, `elf_path: str`\n- The handler should call `run_dwt_explain` from `eab/dwt_explain.py` (created in the previous subtask)\n- Return the result as structured data (narrative text + suggested follow-up watchpoints + events)\n- Handle errors gracefully: if `run_dwt_explain` raises ValueError, return an error message to the LLM rather than crashing\n\nRead the existing tool registrations in `eab/mcp_server.py` carefully and match their pattern exactly (decorator style, parameter validation, return format, error handling). Add the import for `run_dwt_explain` from `eab.dwt_explain` in the internal imports section.",
      "files": [
        "eab/mcp_server.py"
      ]
    },
    {
      "id": "3",
      "description": "Add the `eabctl dwt explain` CLI subcommand to `eab/cli/parser.py`.\n\nThe `dwt` subparser already exists in this file with subcommands: watch, halt, list, clear. Add an `explain` subcommand following the same pattern.\n\nCLI interface:\n- `eabctl dwt explain --device NRF5340_XXAA_APP --symbols conn_interval,mtu_size --elf zephyr.elf --duration 10 --json`\n- `--symbols`: required, comma-separated list of symbol names\n- `--elf`: required, path to ELF file\n- `--duration`: optional, default 5, integer seconds\n- `--device`: optional, device identifier\n- `--json`: optional flag, if set output raw JSON; otherwise output human-readable narrative\n\nThe handler function should:\n1. Parse the comma-separated symbols string into a list\n2. Call `run_dwt_explain` from `eab.dwt_explain`\n3. If `--json` flag: print JSON with keys `events`, `source_context`, `ai_prompt` (where `ai_prompt` is the narrative)\n4. If no `--json` flag: print the narrative text to stdout\n5. Handle ValueError from `run_dwt_explain` by printing an error message and exiting with code 1\n\nRead the existing subcommand registrations (watch, halt, list, clear) and match their pattern exactly for argument parsing, handler binding, and error handling.",
      "files": [
        "eab/cli/parser.py"
      ]
    },
    {
      "id": "4",
      "description": "Create unit tests in `tests/unit/test_dwt_explain.py` covering the DWT explain feature.\n\nAll DWT hardware interaction, JSONL capture, and ELF file access must be mocked. Tests should use pytest and follow patterns from existing tests in `tests/unit/`.\n\nRequired test cases:\n\n1. **ELF enrichment**: Mock pyelftools to return known source file/line for a given address. Verify enrichment function attaches correct source info to events.\n\n2. **Prompt formatting**: Provide a list of pre-enriched events. Verify the output narrative string contains expected elements (symbol names, source references, access types). Verify suggested_watchpoints is a list of strings.\n\n3. **Edge case \u2014 no events captured**: Call `run_dwt_explain` with mocked DWT that returns zero events. Verify the result has an empty events list and the narrative indicates no activity was observed.\n\n4. **Edge case \u2014 unknown symbols**: Call `run_dwt_explain` with symbols that don't exist in the ELF. Verify a ValueError is raised with a descriptive message.\n\n5. **Edge case \u2014 invalid duration**: Call `run_dwt_explain` with `duration_s=0` and `duration_s=-1`. Verify ValueError is raised.\n\n6. **CLI JSON output**: Mock `run_dwt_explain` and simulate the CLI handler with `--json` flag. Verify output is valid JSON with keys `events`, `source_context`, `ai_prompt`.\n\n7. **MCP tool handler**: Mock `run_dwt_explain` and call the MCP tool handler directly. Verify it returns the expected structured response format.\n\nUse `unittest.mock.patch` to mock `eab.dwt_explain` internals (DWT arming, JSONL capture, ELF resolution). Use `tmp_path` fixture for any temporary file needs. All tests must be independent and not require hardware.",
      "files": [
        "tests/unit/test_dwt_explain.py"
      ]
    }
  ],
  "strategy": "execute",
  "deferred_work": ""
}