# Implementation Plan: ESP32 esp_apptrace Support (Issue #105)

## Context

ESP32 chips support high-speed application-level tracing via OpenOCD's `esp apptrace` commands. This is similar to RTT but:
- Works reliably on ESP32 (unlike probe-rs RTT which has driver bugs)
- Uses JTAG transport (much faster than UART)
- Already has firmware API (`esp_app_trace.h`)
- Supported by Espressif OpenOCD (installed at `~/.espressif/tools/openocd-esp32/`)

The existing EAB trace subsystem already supports multiple sources (RTT, serial, logfile). We can add esp_apptrace as a fourth source.

## Hardware Available

- ESP32-C6 dev board (USB-JTAG built-in at `/dev/tty.usbmodem*`)
- Espressif OpenOCD v0.12.0 installed
- ESP-IDF with apptrace examples at `/Users/shane/esp/esp-idf/examples/system/app_trace_basic/`

## Architecture

### Firmware Side

ESP-IDF provides:
```c
#include "esp_app_trace.h"

// Check if OpenOCD is connected
esp_apptrace_host_is_connected(ESP_APPTRACE_DEST_JTAG)

// Write trace data
esp_apptrace_write(ESP_APPTRACE_DEST_JTAG, buf, len, timeout)

// Flush buffer
esp_apptrace_flush(ESP_APPTRACE_DEST_JTAG, timeout)
```

Requires sdkconfig:
```
CONFIG_APPTRACE_DEST_JTAG=y
CONFIG_APPTRACE_ENABLE=y
```

### Host Side (OpenOCD Commands)

Via telnet to port 4444:
```
esp apptrace start file://output.log 0 <max_len> <poll_period> <skip_count> <wait_rst>
esp apptrace stop
esp apptrace status
```

### Integration with EAB

Follow the same pattern as RTT/serial/logfile sources:

1. **OpenOCDApptrace Transport** class (new file: `eab/apptrace_transport.py`)
   - Manages OpenOCD subprocess
   - Sends telnet commands to port 4444
   - Captures trace output to a file
   - Returns file handle for tailing

2. **Trace worker** reuse
   - Existing `_apptrace_worker.py` (create new, similar to `_rtt_worker.py`)
   - Subprocess that connects to OpenOCD telnet, starts apptrace, tails output
   - Writes to `.rttbin` format (reuse existing format)

3. **CLI integration** (extend `eab/cli/trace/cmd_start.py`)
   - Add `--source apptrace` option
   - Add `--device` flag to specify ESP32 variant (esp32c6, esp32s3, etc.)
   - Auto-detect board config from device name

## Implementation Steps

### Phase 1: Test Firmware (examples/esp32c6-apptrace-test/)

Create new example firmware based on `app_trace_basic` with:

1. **Enable apptrace in sdkconfig.defaults**:
   ```
   CONFIG_APPTRACE_DEST_JTAG=y
   CONFIG_APPTRACE_ENABLE=y
   CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG=y
   CONFIG_IDF_TARGET="esp32c6"
   ```

2. **Firmware features**:
   - Periodic heartbeat via apptrace (every 100ms for high-throughput test)
   - Pattern markers for Perfetto visualization
   - Command response via apptrace
   - Timestamp counter for latency measurement

3. **Build and flash**:
   ```bash
   eabctl flash examples/esp32c6-apptrace-test
   ```

### Phase 2: Manual OpenOCD Test

Before implementing the Python transport, verify OpenOCD apptrace works:

1. Start OpenOCD manually:
   ```bash
   ~/.espressif/tools/openocd-esp32/*/openocd-esp32/bin/openocd \
     -f board/esp32c6-builtin.cfg
   ```

2. Connect via telnet:
   ```bash
   telnet localhost 4444
   ```

3. Start apptrace capture:
   ```
   esp apptrace start file:///tmp/apptrace.log 0 1000000 1 0 0
   ```

4. Verify output file receives data:
   ```bash
   tail -f /tmp/apptrace.log
   ```

5. Stop capture:
   ```
   esp apptrace stop
   ```

**Success criteria**: Firmware heartbeat data appears in `/tmp/apptrace.log`.

### Phase 3: Python OpenOCD Transport

Create `eab/apptrace_transport.py`:

```python
class OpenOCDApptrace:
    """Manages OpenOCD subprocess and telnet connection for esp_apptrace."""

    def __init__(self, board_cfg: str = "board/esp32c6-builtin.cfg"):
        self.openocd_path = self._find_espressif_openocd()
        self.board_cfg = board_cfg
        self.openocd_proc = None
        self.telnet_host = "localhost"
        self.telnet_port = 4444

    def start_openocd(self) -> None:
        """Start OpenOCD subprocess in background."""
        # Launch: openocd -f board/esp32c6-builtin.cfg
        # Wait for "Info : Listening on port 4444"

    def connect_telnet(self) -> telnetlib.Telnet:
        """Connect to OpenOCD telnet interface."""

    def start_apptrace(self, output_file: str, max_len: int = 0) -> None:
        """Send 'esp apptrace start' command via telnet."""

    def stop_apptrace(self) -> None:
        """Send 'esp apptrace stop' command via telnet."""

    def get_apptrace_status(self) -> str:
        """Query apptrace status via telnet."""

    def tail_apptrace_file(self, output_file: str) -> Generator[bytes]:
        """Tail the apptrace output file, yielding new data."""

    def stop_openocd(self) -> None:
        """Send 'shutdown' command and terminate OpenOCD."""
```

**Key implementation details**:
- OpenOCD runs as a subprocess (like J-Link RTT server)
- Use `telnetlib` or `pexpect` for telnet commands
- Parse OpenOCD stdout for "Listening on port 4444" before connecting
- Handle OpenOCD restarts gracefully (e.g., if it crashes)

### Phase 4: Trace Worker

Create `eab/cli/trace/_apptrace_worker.py`:

```python
def main() -> None:
    """Entry point for apptrace capture subprocess."""
    device = sys.argv[1]        # e.g., "esp32c6"
    channel = int(sys.argv[2])  # (ignored for apptrace, kept for compatibility)
    output_path = sys.argv[3]   # .rttbin output
    eab_root = sys.argv[4]

    from eab.apptrace_transport import OpenOCDApptrace
    from eab.rtt_binary import RTTBinaryCapture

    # Map device name to board config
    board_cfg = f"board/{device}-builtin.cfg"

    transport = OpenOCDApptrace(board_cfg=board_cfg)
    transport.start_openocd()
    transport.start_apptrace(output_file="/tmp/apptrace.log")

    # Tail apptrace file and write to .rttbin
    capture = RTTBinaryCapture(
        transport=transport,  # Wrap to provide read() interface
        device=device,
        channels=[channel],
        output_path=output_path,
        sample_width=1,
        timestamp_hz=1000,
    )

    capture.start()
    # ... signal handlers, wait loop
```

**Note**: `RTTBinaryCapture` may need minor adaptation to accept a "file-tailing transport" instead of a "socket transport". Could refactor to accept any iterable that yields `(timestamp, data)` tuples.

### Phase 5: CLI Integration

Extend `eab/cli/trace/cmd_start.py`:

```python
@cli.command("start")
@click.option("--source", type=click.Choice(["rtt", "serial", "logfile", "apptrace"]))
@click.option("--device", help="Device name (e.g., esp32c6, NRF5340_XXAA_APP)")
def cmd_trace_start(source: str, device: str, ...):
    if source == "apptrace":
        # Validate device is ESP32 variant
        if not device.startswith("esp32"):
            raise click.UsageError("--source apptrace requires --device esp32*")

        # Launch apptrace worker subprocess
        cmd = [
            sys.executable, "-m", "eab.cli.trace._apptrace_worker",
            device, str(channel), output_path, eab_root
        ]
        proc = subprocess.Popen(cmd, ...)
        # ... same pattern as RTT worker
```

### Phase 6: Hardware Testing

Test on ESP32-C6:

1. Build and flash apptrace firmware:
   ```bash
   eabctl flash examples/esp32c6-apptrace-test
   ```

2. Start apptrace capture:
   ```bash
   eabctl trace start --source apptrace --device esp32c6 -o /tmp/trace.rttbin
   ```

3. Verify data capture:
   ```bash
   # Check .rttbin file is growing
   ls -lh /tmp/trace.rttbin
   ```

4. Export to Perfetto JSON:
   ```bash
   eabctl trace export -i /tmp/trace.rttbin -o /tmp/trace.json
   ```

5. Open in Perfetto UI:
   - https://ui.perfetto.dev
   - Load `/tmp/trace.json`
   - Verify heartbeat events appear on timeline

**Success criteria**:
- ✅ OpenOCD starts and connects to ESP32-C6
- ✅ Apptrace capture receives firmware data
- ✅ Data written to `.rttbin` format
- ✅ Perfetto export shows timeline events

### Phase 7: Documentation

Update files:

1. **CLAUDE.md** - Add apptrace to trace examples:
   ```bash
   # ESP32 apptrace (high-speed JTAG streaming)
   eabctl trace start --source apptrace --device esp32c6 -o /tmp/trace.rttbin
   ```

2. **README.md** - Document new source type

3. **examples/esp32c6-apptrace-test/README.md** - Quickstart guide

4. **GitHub Issue #105** - Close with PR link and example usage

## Files to Create/Modify

### New Files
- `eab/apptrace_transport.py` - OpenOCD apptrace transport class
- `eab/cli/trace/_apptrace_worker.py` - Subprocess worker
- `examples/esp32c6-apptrace-test/` - Test firmware

### Modified Files
- `eab/cli/trace/cmd_start.py` - Add `--source apptrace` option
- `eab/cli/trace/__init__.py` - Register apptrace commands
- `CLAUDE.md` - Add apptrace examples
- `README.md` - Document apptrace source

## Testing Checklist

- [ ] Manual OpenOCD apptrace test (Phase 2)
- [ ] Python transport connects to OpenOCD telnet
- [ ] Apptrace start command works via Python
- [ ] Apptrace output file receives data
- [ ] Worker subprocess writes `.rttbin` format
- [ ] CLI command launches worker successfully
- [ ] Export to Perfetto JSON works
- [ ] Perfetto UI visualizes timeline correctly
- [ ] Stop command terminates OpenOCD cleanly
- [ ] Graceful handling of OpenOCD crashes
- [ ] Works with multiple ESP32 variants (esp32c6, esp32s3, esp32c3)

## Open Questions

1. **RTTBinaryCapture compatibility**: Does it need refactoring to accept file-tailing sources?
   - Current design assumes socket-based transport (JLinkTransport)
   - Apptrace would tail a file instead
   - May need to abstract the "data source" interface

2. **Multi-device support**: Can OpenOCD apptrace capture from multiple ESP32s?
   - Probably requires separate OpenOCD instances with different ports
   - Not critical for MVP

3. **Apptrace vs UART**: Should firmware log to both?
   - ESP-IDF allows both `CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG` and `CONFIG_APPTRACE_ENABLE`
   - Could send debug logs to UART, high-volume trace to apptrace
   - Test this in Phase 1 firmware

## Success Criteria

✅ ESP32-C6 firmware sends data via `esp_apptrace_write()`
✅ OpenOCD captures data to file via `esp apptrace start`
✅ Python transport manages OpenOCD lifecycle
✅ CLI command starts apptrace worker subprocess
✅ Data written to `.rttbin` format
✅ Perfetto export and visualization works
✅ Documentation updated
✅ GitHub issue #105 closed with working example

## Risks and Mitigations

| Risk | Likelihood | Mitigation |
|------|-----------|------------|
| OpenOCD unstable/crashes | Medium | Auto-restart logic, error logging |
| Telnet commands fail | Low | Retry logic, timeout handling |
| Apptrace output format incompatible | Low | Parse raw output, convert to .rttbin |
| USB-JTAG port busy | Medium | Check port availability before starting |
| Firmware doesn't connect | Low | Wait loop with timeout, clear error messages |

## Timeline Estimate

- Phase 1 (Firmware): 1 hour
- Phase 2 (Manual test): 30 minutes
- Phase 3 (Python transport): 2 hours
- Phase 4 (Worker subprocess): 1 hour
- Phase 5 (CLI integration): 1 hour
- Phase 6 (Hardware testing): 1 hour
- Phase 7 (Documentation): 30 minutes

**Total**: ~7.5 hours (autonomous overnight work)

## Next Steps After Plan Approval

1. Create firmware example with apptrace enabled
2. Manual OpenOCD test to verify protocol
3. Implement Python OpenOCD transport class
4. Create worker subprocess
5. Integrate with CLI
6. Test on ESP32-C6 hardware
7. Document and close issue

