#!/bin/bash
# EAB Daemon Control Script
# AGENTS: Use this script for ALL ESP32 operations. Never use esptool directly!
#
# Quick reference:
#   eab-control status      - Check device status
#   eab-control tail 50     - View serial output
#   eab-control events 50   - View recent daemon events
#   eab-control send "i"    - Send command to device
#   eab-control stream ...  - Configure high-speed data stream
#   eab-control recv ...    - Read bytes from data.bin
#   eab-control flash <dir> - Flash firmware (handles port automatically)
#   eab-control reset       - Reset device

PLIST="$HOME/Library/LaunchAgents/com.eab.daemon.plist"
EAB_DIR="$HOME/tools/embedded-agent-bridge"
SELF_PATH="$(cd "$(dirname "$0")" && pwd)/$(basename "$0")"

# Always invoke tooling from inside EAB_DIR so the local `eab/` package is importable.
eabctl_cmd() {
    (cd "$EAB_DIR" && ./eabctl "$@")
}

# Helper function to check if daemon is running and port is available
check_daemon() {
    if [ ! -f /tmp/eab-session/status.json ]; then
        echo "ERROR: EAB daemon is not running!"
        echo ""
        echo "To fix: Run 'eab-control start' or restart the daemon"
        return 1
    fi
    return 0
}

# Helper function to get port with helpful error message
get_port() {
    PORT=$(cat /tmp/eab-session/status.json 2>/dev/null | grep -o '"port": "[^"]*"' | cut -d'"' -f4)
    if [ -z "$PORT" ]; then
        echo ""
        echo "=========================================="
        echo "ERROR: Could not get port from EAB daemon"
        echo "=========================================="
        echo ""
        echo "The daemon may not be running. Try:"
        echo "  1. eab-control status    # Check what's happening"
        echo "  2. eab-control start     # Start the daemon"
        echo ""
        return 1
    fi
    echo "$PORT"
    return 0
}

# Helper to verify port is actually released before flashing
verify_port_released() {
    local PORT="$1"
    local MAX_WAIT=10
    local COUNT=0

    while [ $COUNT -lt $MAX_WAIT ]; do
        # Check if any process is using the port
        if ! lsof "$PORT" >/dev/null 2>&1; then
            return 0  # Port is free
        fi
        echo "Waiting for port to be released... ($COUNT/$MAX_WAIT)"
        sleep 1
        COUNT=$((COUNT + 1))
    done

    echo ""
    echo "WARNING: Port $PORT may still be in use by:"
    lsof "$PORT" 2>/dev/null
    echo ""
    return 1
}

case "$1" in
    start)
        echo "Starting EAB daemon..."
        FORCE_FLAG=""
        if [ "$2" = "--force" ]; then
            FORCE_FLAG="--force"
        fi

        # Prefer the in-repo daemon supervisor (reliable even when launchd env is minimal).
        (cd "$EAB_DIR" && ./eabctl --base-dir /tmp/eab-session start --port auto --baud 115200 $FORCE_FLAG) >/dev/null 2>&1 || true

        # Also try to start via launchd when installed (keeps it running across sessions).
        launchctl load "$PLIST" 2>/dev/null || launchctl start com.eab.daemon 2>/dev/null || true

        sleep 1
        eabctl_cmd status
        ;;

    stop)
        echo "Stopping EAB daemon..."
        launchctl stop com.eab.daemon 2>/dev/null
        launchctl unload "$PLIST" 2>/dev/null
        eabctl_cmd stop >/dev/null 2>&1 || true
        # Also kill any orphaned processes
        pkill -f "python3 -m eab" 2>/dev/null
        pkill -f " -m eab.daemon" 2>/dev/null
        echo "EAB daemon stopped"
        ;;

    restart)
        "$SELF_PATH" stop
        sleep 2
        "$SELF_PATH" start
        ;;

    status)
        if [ "$2" = "--json" ]; then
            (cd "$EAB_DIR" && ./eabctl status --json)
            exit $?
        fi
        echo "=== LaunchAgent Status ==="
        if launchctl list | grep -q com.eab.daemon; then
            echo "Service: LOADED"
            launchctl list com.eab.daemon
        else
            echo "Service: NOT LOADED"
        fi
        echo ""
        echo "=== EAB Daemon Status ==="
        eabctl_cmd status
        echo ""
        echo "=== Session Files ==="
        ls -la /tmp/eab-session/ 2>/dev/null || echo "No session directory"
        ;;

    logs)
        echo "=== Daemon stdout ==="
        tail -50 /tmp/eab-daemon.log 2>/dev/null || echo "No stdout log"
        echo ""
        echo "=== Daemon stderr ==="
        tail -50 /tmp/eab-daemon.err 2>/dev/null || echo "No stderr log"
        echo ""
        echo "=== Session latest.log ==="
        tail -30 /tmp/eab-session/latest.log 2>/dev/null || echo "No session log"
        ;;

    enable)
        echo "Enabling EAB daemon to start at login..."
        launchctl load "$PLIST"
        echo "Done. EAB will start automatically when you log in."
        ;;

    disable)
        echo "Disabling EAB daemon..."
        launchctl unload "$PLIST" 2>/dev/null
        echo "Done. EAB will not start automatically."
        ;;

    pause)
        SECONDS="${2:-120}"
        echo "Pausing EAB daemon for ${SECONDS}s to release serial port..."
        eabctl_cmd pause "$SECONDS"
        ;;

    resume)
        echo "Resuming EAB daemon (removing pause file)..."
        eabctl_cmd resume >/dev/null 2>&1 || rm -f /tmp/eab-session/pause.txt
        echo "Daemon will resume on next loop iteration."
        ;;

    reset)
        echo "Sending reset command to ESP32..."
        eabctl_cmd send "!RESET"
        ;;

    cmd)
        if [ -z "$2" ]; then
            echo "Usage: eab-control cmd <command>"
            echo "Example: eab-control cmd '!CHIP_INFO'"
            exit 1
        fi
        eabctl_cmd send "$2"
        ;;

    tail)
        JSON=false
        LINES=50
        if [ "$2" = "--json" ]; then
            JSON=true
        elif [ -n "$2" ]; then
            LINES="$2"
        fi
        if [ "$3" = "--json" ]; then
            JSON=true
        fi

        if [ "$JSON" = true ]; then
            (cd "$EAB_DIR" && ./eabctl tail -n "$LINES" --json)
        else
            eabctl_cmd tail -n "$LINES"
        fi
        ;;

    alerts)
        JSON=false
        LINES=20
        if [ "$2" = "--json" ]; then
            JSON=true
        elif [ -n "$2" ]; then
            LINES="$2"
        fi
        if [ "$3" = "--json" ]; then
            JSON=true
        fi

        if [ "$JSON" = true ]; then
            (cd "$EAB_DIR" && ./eabctl alerts -n "$LINES" --json)
        else
            eabctl_cmd alerts -n "$LINES"
        fi
        ;;

    events)
        JSON=false
        LINES=50
        if [ "$2" = "--json" ]; then
            JSON=true
        elif [ -n "$2" ]; then
            LINES="$2"
        fi
        if [ "$3" = "--json" ]; then
            JSON=true
        fi

        if [ "$JSON" = true ]; then
            (cd "$EAB_DIR" && ./eabctl events -n "$LINES" --json)
        else
            (cd "$EAB_DIR" && ./eabctl events -n "$LINES")
        fi
        ;;

    diagnose)
        if [ "$2" = "--json" ]; then
            (cd "$EAB_DIR" && ./eabctl diagnose --json)
        else
            (cd "$EAB_DIR" && ./eabctl diagnose)
        fi
        ;;

    capture-between)
        if [ -z "$2" ] || [ -z "$3" ] || [ -z "$4" ]; then
            echo "Usage: eab-control capture-between <start_marker> <end_marker> <output_file> [--decode-base64] [--json]"
            exit 1
        fi
        (cd "$EAB_DIR" && ./eabctl capture-between "$2" "$3" "$4" "${@:5}")
        ;;

    wait)
        if [ -z "$2" ]; then
            echo "Usage: eab-control wait <pattern> [timeout]"
            echo "Example: eab-control wait 'Ready' 30"
            exit 1
        fi
        TIMEOUT="${3:-30}"
        eabctl_cmd wait "$2" "$TIMEOUT"
        ;;

    wait-event)
        if [ -z "$2" ]; then
            echo "Usage: eab-control wait-event --type <event_type> [--timeout <seconds>]"
            echo "Example: eab-control wait-event --type command_sent --timeout 10"
            exit 1
        fi
        (cd "$EAB_DIR" && ./eabctl wait-event "${@:2}")
        ;;

    stream)
        if [ -z "$2" ]; then
            echo "Usage: eab-control stream start|stop [--mode raw|base64] [--chunk N] [--marker STR] [--no-patterns] [--truncate]"
            exit 1
        fi
        (cd "$EAB_DIR" && ./eabctl stream "${@:2}")
        ;;

    recv)
        if [ -z "$2" ]; then
            echo "Usage: eab-control recv --offset N --length M [--out file] [--base64]"
            exit 1
        fi
        (cd "$EAB_DIR" && ./eabctl recv "${@:2}")
        ;;

    recv-latest)
        if [ -z "$2" ]; then
            echo "Usage: eab-control recv-latest --bytes N [--out file] [--base64]"
            exit 1
        fi
        (cd "$EAB_DIR" && ./eabctl recv-latest "${@:2}")
        ;;

    preflight)
        # Pre-flight check for agents - verify everything is ready for flashing
        echo "=== EAB Pre-Flight Check ==="
        echo ""

        ERRORS=0

        # Check 1: Daemon running
        if [ -f /tmp/eab-session/status.json ]; then
            echo "[OK] Daemon status file exists"
        else
            echo "[FAIL] Daemon not running!"
            echo "       Fix: Run 'eab-control start'"
            ERRORS=$((ERRORS + 1))
        fi

        # Check 2: Port available
        PORT=$(cat /tmp/eab-session/status.json 2>/dev/null | grep -o '"port": "[^"]*"' | cut -d'"' -f4)
        if [ -n "$PORT" ]; then
            echo "[OK] Port detected: $PORT"

            # Check if port device exists
            if [ -e "$PORT" ]; then
                echo "[OK] Port device exists"
            else
                echo "[FAIL] Port device missing (USB disconnected?)"
                ERRORS=$((ERRORS + 1))
            fi
        else
            echo "[FAIL] No port in daemon status"
            ERRORS=$((ERRORS + 1))
        fi

        # Check 3: Connection status
        CONN_STATUS=$(cat /tmp/eab-session/status.json 2>/dev/null | grep -o '"status": "[^"]*"' | head -1 | cut -d'"' -f4)
        if [ "$CONN_STATUS" = "connected" ]; then
            echo "[OK] Connection status: connected"
        else
            echo "[WARN] Connection status: $CONN_STATUS"
        fi

        # Check 4: Health status
        HEALTH=$(cat /tmp/eab-session/status.json 2>/dev/null | grep -o '"status": "[^"]*"' | tail -1 | cut -d'"' -f4)
        if [ "$HEALTH" = "healthy" ]; then
            echo "[OK] Health status: healthy"
        else
            echo "[WARN] Health status: $HEALTH"
        fi

        echo ""
        if [ $ERRORS -eq 0 ]; then
            echo "=== All checks passed! Ready to flash. ==="
            echo ""
            echo "Use: eab-control flash <project_dir>"
            exit 0
        else
            echo "=== $ERRORS check(s) failed ==="
            echo ""
            echo "Fix the issues above before flashing."
            exit 1
        fi
        ;;

    flash)
        # Flash ESP-IDF project or single binary
        # Usage: eab-control flash <project_dir_or_bin> [chip]
        if [ -z "$2" ]; then
            echo "=========================================="
            echo "EAB Flash Tool"
            echo "=========================================="
            echo ""
            echo "Usage: eab-control flash <project_dir_or_bin> [chip]"
            echo ""
            echo "Examples:"
            echo "  eab-control flash ./my_project           # Flash ESP-IDF project"
            echo "  eab-control flash ./my_project esp32s3   # Specify chip type"
            echo "  eab-control flash ./firmware.bin         # Flash single binary"
            echo ""
            echo "For ESP-IDF projects, looks for build/ directory with:"
            echo "  - bootloader/bootloader.bin"
            echo "  - partition_table/partition-table.bin"
            echo "  - <project_name>.bin"
            echo ""
            echo "IMPORTANT: Always use this command instead of esptool directly!"
            echo "This command handles port management automatically."
            exit 1
        fi

        TARGET="$2"
        CHIP="${3:-auto}"

        # Use helper function to get port with clear error messages
        if ! check_daemon; then
            exit 1
        fi

        PORT=$(get_port)
        if [ $? -ne 0 ]; then
            exit 1
        fi

        echo "=== EAB Flash Tool ==="
        echo "Port: $PORT"
        echo "Target: $TARGET"

	        # Pause daemon to release port
	        echo ""
	        echo "Pausing daemon..."
	        eabctl_cmd pause 120
	        sleep 1

        # Verify port is released before flashing
        if ! verify_port_released "$PORT"; then
            echo ""
            echo "=========================================="
            echo "ERROR: Port not released in time!"
            echo "=========================================="
            echo ""
            echo "The serial port is still busy. This usually means:"
            echo "  1. The daemon didn't pause properly"
            echo "  2. Another process is using the port"
            echo ""
            echo "Try:"
            echo "  1. eab-control stop     # Stop the daemon"
            echo "  2. eab-control start    # Restart it"
            echo "  3. eab-control flash    # Try again"
            rm -f /tmp/eab-session/pause.txt
            exit 1
        fi

        # Determine if this is a project directory or single binary
        if [ -d "$TARGET" ]; then
            # ESP-IDF project directory
            BUILD_DIR="$TARGET/build"
            if [ ! -d "$BUILD_DIR" ]; then
                echo "ERROR: No build/ directory found in $TARGET"
                echo "Run 'idf.py build' first."
                rm -f /tmp/eab-session/pause.txt
                exit 1
            fi

            # Find the app binary (usually named after project)
            APP_BIN=$(ls "$BUILD_DIR"/*.bin 2>/dev/null | grep -v bootloader | grep -v partition | head -1)
            BOOTLOADER="$BUILD_DIR/bootloader/bootloader.bin"
            PARTITION="$BUILD_DIR/partition_table/partition-table.bin"

            if [ ! -f "$APP_BIN" ]; then
                echo "ERROR: No app binary found in $BUILD_DIR"
                rm -f /tmp/eab-session/pause.txt
                exit 1
            fi

            echo "Bootloader: $BOOTLOADER"
            echo "Partition:  $PARTITION"
            echo "App:        $APP_BIN"
            echo ""

            # Auto-detect chip from build if not specified
            if [ "$CHIP" = "auto" ]; then
                if [ -f "$BUILD_DIR/config/sdkconfig.h" ]; then
                    if grep -q "CONFIG_IDF_TARGET_ESP32S3" "$BUILD_DIR/config/sdkconfig.h"; then
                        CHIP="esp32s3"
                    elif grep -q "CONFIG_IDF_TARGET_ESP32S2" "$BUILD_DIR/config/sdkconfig.h"; then
                        CHIP="esp32s2"
                    elif grep -q "CONFIG_IDF_TARGET_ESP32C3" "$BUILD_DIR/config/sdkconfig.h"; then
                        CHIP="esp32c3"
                    else
                        CHIP="esp32"
                    fi
                fi
            fi

            echo "Chip: $CHIP"
            echo ""
            echo "Flashing..."

            TMPLOG="$(mktemp /tmp/eab-flash.XXXXXX.log 2>/dev/null || echo /tmp/eab-flash.log)"
            esptool --chip "$CHIP" --port "$PORT" --baud 921600 \
                --before default-reset --after hard-reset \
                write-flash --flash-mode dio --flash-size detect --flash-freq 80m \
                0x0 "$BOOTLOADER" \
                0x8000 "$PARTITION" \
                0x10000 "$APP_BIN" 2>&1 | tee "$TMPLOG"
            RESULT=${PIPESTATUS[0]}

            # Sandbox fallback: if we can't open the serial device from this process,
            # flash via the EAB daemon itself using !FLASH on a merged image.
            if [ $RESULT -ne 0 ] && grep -qi "Operation not permitted" "$TMPLOG"; then
                echo ""
                echo "Detected serial permission restrictions; falling back to daemon-based flashing..."

                MERGED_BIN="$BUILD_DIR/eab_merged_flash.bin"
                echo "Merging images to: $MERGED_BIN"
                esptool.py --chip "$CHIP" merge_bin -o "$MERGED_BIN" \
                    --flash-mode dio --flash-freq 80m --flash-size 4MB \
                    0x0 "$BOOTLOADER" \
                    0x8000 "$PARTITION" \
                    0x10000 "$APP_BIN"
                MERGE_RESULT=$?
                if [ $MERGE_RESULT -ne 0 ] || [ ! -f "$MERGED_BIN" ]; then
                    echo "ERROR: Failed to create merged image for daemon flash"
                    rm -f /tmp/eab-session/pause.txt
                    exit 1
                fi

                echo ""
                echo "Resuming daemon..."
                rm -f /tmp/eab-session/pause.txt
                sleep 2

                echo "Requesting daemon flash via !FLASH..."
                "$SELF_PATH" cmd "!FLASH:$MERGED_BIN"

                echo "Waiting for flash completion..."
                if "$SELF_PATH" wait "OK: Flash complete" 240; then
                    echo ""
                    echo "=== Flash successful (daemon) ==="
                    sleep 2
                    "$SELF_PATH" tail 20
                    exit 0
                fi

                echo ""
                echo "=========================================="
                echo "ERROR: Daemon flash did not complete in time"
                echo "=========================================="
                echo ""
                "$SELF_PATH" tail 50
                exit 1
            fi
        else
            # Single binary file
            if [ ! -f "$TARGET" ]; then
                echo "ERROR: File not found: $TARGET"
                rm -f /tmp/eab-session/pause.txt
                exit 1
            fi

            echo "Flashing single binary..."
            esptool --chip "$CHIP" --port "$PORT" --baud 921600 \
                write-flash 0x0 "$TARGET"
            RESULT=$?
        fi

        # Resume daemon
        echo ""
        echo "Resuming daemon..."
        rm -f /tmp/eab-session/pause.txt
        sleep 2

        if [ $RESULT -eq 0 ]; then
            echo ""
            echo "=== Flash successful! ==="
            # Show output after reset
            sleep 2
            "$SELF_PATH" tail 20
        else
            echo ""
            echo "=========================================="
            echo "ERROR: Flash FAILED"
            echo "=========================================="
            echo ""
            echo "Common causes:"
            echo "  1. Wrong chip type (try specifying: eab-control flash <dir> esp32s3)"
            echo "  2. Device in bad state (try: eab-control erase first)"
            echo "  3. USB connection issue (check cable)"
            echo ""
            exit 1
        fi
        ;;

    erase)
        # Erase entire flash
        if ! check_daemon; then
            exit 1
        fi

        PORT=$(get_port)
        if [ $? -ne 0 ]; then
            exit 1
        fi

        echo "=== EAB Erase Flash ==="
        echo "Port: $PORT"
        echo ""

	        echo "Pausing daemon..."
	        eabctl_cmd pause 120
	        sleep 1

        # Verify port is released
        if ! verify_port_released "$PORT"; then
            echo "ERROR: Port not released!"
            rm -f /tmp/eab-session/pause.txt
            exit 1
        fi

        echo "Erasing flash on $PORT..."
        esptool --port "$PORT" erase-flash
        RESULT=$?

        echo "Resuming daemon..."
        rm -f /tmp/eab-session/pause.txt

        if [ $RESULT -eq 0 ]; then
            echo ""
            echo "=== Flash erased successfully ==="
        else
            echo ""
            echo "=== Erase FAILED ==="
            exit 1
        fi
        ;;

    chip-info)
        # Get chip info
        PORT=$(cat /tmp/eab-session/status.json 2>/dev/null | grep -o '"port": "[^"]*"' | cut -d'"' -f4)
        if [ -z "$PORT" ]; then
            echo "ERROR: Could not get port from daemon. Is daemon running?"
            exit 1
        fi

	        echo "Pausing daemon..."
	        eabctl_cmd pause 30
	        sleep 1

        echo "Getting chip info from $PORT..."
        esptool --port "$PORT" chip-id
        esptool --port "$PORT" flash-id

        echo "Resuming daemon..."
        rm -f /tmp/eab-session/pause.txt
        ;;

    backup)
        # Backup flash to file
        OUTFILE="${2:-esp32_backup_$(date +%Y%m%d_%H%M%S).bin}"
        SIZE="${3:-0x400000}"  # Default 4MB

        PORT=$(cat /tmp/eab-session/status.json 2>/dev/null | grep -o '"port": "[^"]*"' | cut -d'"' -f4)
        if [ -z "$PORT" ]; then
            echo "ERROR: Could not get port from daemon. Is daemon running?"
            exit 1
        fi

        echo "=== Backup Flash ==="
        echo "Port: $PORT"
        echo "Output: $OUTFILE"
        echo "Size: $SIZE"
        echo ""

	        echo "Pausing daemon..."
	        eabctl_cmd pause 300
	        sleep 1

        echo "Reading flash..."
        esptool --port "$PORT" read-flash 0x0 "$SIZE" "$OUTFILE"
        RESULT=$?

        echo "Resuming daemon..."
        rm -f /tmp/eab-session/pause.txt

        if [ $RESULT -eq 0 ]; then
            echo ""
            echo "=== Backup complete: $OUTFILE ==="
            ls -lh "$OUTFILE"
        else
            echo "=== Backup FAILED ==="
            exit 1
        fi
        ;;

    restore)
        # Restore flash from backup file
        if [ -z "$2" ]; then
            echo "Usage: eab-control restore <backup.bin>"
            echo ""
            echo "Restores a full flash backup created with 'eab-control backup'"
            exit 1
        fi

        INFILE="$2"
        if [ ! -f "$INFILE" ]; then
            echo "ERROR: File not found: $INFILE"
            exit 1
        fi

        PORT=$(cat /tmp/eab-session/status.json 2>/dev/null | grep -o '"port": "[^"]*"' | cut -d'"' -f4)
        if [ -z "$PORT" ]; then
            echo "ERROR: Could not get port from daemon. Is daemon running?"
            exit 1
        fi

        echo "=== Restore Flash ==="
        echo "Port: $PORT"
        echo "Input: $INFILE"
        echo ""
        echo "WARNING: This will overwrite ALL flash contents!"
        echo ""

	        echo "Pausing daemon..."
	        eabctl_cmd pause 300
	        sleep 1

        echo "Writing flash..."
        esptool --port "$PORT" --baud 921600 write-flash 0x0 "$INFILE"
        RESULT=$?

        echo "Resuming daemon..."
        rm -f /tmp/eab-session/pause.txt
        sleep 2

        if [ $RESULT -eq 0 ]; then
            echo ""
            echo "=== Restore complete ==="
            "$SELF_PATH" tail 20
        else
            echo "=== Restore FAILED ==="
            exit 1
        fi
        ;;

    read-mac)
        # Read MAC address
        PORT=$(cat /tmp/eab-session/status.json 2>/dev/null | grep -o '"port": "[^"]*"' | cut -d'"' -f4)
        if [ -z "$PORT" ]; then
            echo "ERROR: Could not get port from daemon. Is daemon running?"
            exit 1
        fi

	        echo "Pausing daemon..."
	        eabctl_cmd pause 30
	        sleep 1

        esptool --port "$PORT" read-mac

        echo "Resuming daemon..."
        rm -f /tmp/eab-session/pause.txt
        ;;

    build-flash)
        # Build and flash ESP-IDF project
        if [ -z "$2" ]; then
            echo "Usage: eab-control build-flash <project_dir>"
            echo ""
            echo "Builds the ESP-IDF project and flashes it"
            exit 1
        fi

        TARGET="$2"
        if [ ! -d "$TARGET" ]; then
            echo "ERROR: Directory not found: $TARGET"
            exit 1
        fi

        echo "=== Build and Flash ==="
        echo "Project: $TARGET"
        echo ""

        # Check for CMakeLists.txt (ESP-IDF project)
        if [ ! -f "$TARGET/CMakeLists.txt" ]; then
            echo "ERROR: No CMakeLists.txt found. Is this an ESP-IDF project?"
            exit 1
        fi

        echo "Building..."
        cd "$TARGET" && idf.py build
        RESULT=$?

        if [ $RESULT -ne 0 ]; then
            echo "=== Build FAILED ==="
            exit 1
        fi

        echo ""
        echo "Build successful, now flashing..."
        "$SELF_PATH" flash "$TARGET"
        ;;

    monitor)
        # Interactive monitor (just show tail continuously)
        echo "=== Live Serial Monitor ==="
        echo "Press Ctrl+C to exit"
        echo ""
        tail -f /tmp/eab-session/latest.log
        ;;

    send)
        # Send text to device (through daemon)
        if [ -z "$2" ]; then
            echo "Usage: eab-control send <text>"
            echo ""
            echo "Sends text to the ESP32 serial port"
            echo "Example: eab-control send 'r'  # Send 'r' to start recording"
            exit 1
        fi

	        TEXT="$2"
	        echo "Sending: $TEXT"
	        eabctl_cmd send "$TEXT"
	        sleep 1
	        "$SELF_PATH" tail 10
	        ;;

    *)
        echo "EAB Daemon Control"
        echo ""
        echo "Usage: eab-control [command]"
        echo ""
        echo "Daemon Commands:"
        echo "  start      - Start the daemon now"
        echo "  stop       - Stop the daemon"
        echo "  restart    - Restart the daemon"
        echo "  status     - Show daemon status"
        echo "  logs       - Show daemon logs (stdout/stderr)"
        echo "  enable     - Enable auto-start at login"
        echo "  disable    - Disable auto-start"
        echo "  diagnose   - Automated health checks (add --json for agents)"
        echo ""
        echo "Port Control:"
        echo "  pause [N]  - Pause for N seconds (default 120) to release serial port"
        echo "  resume     - Resume from pause early"
        echo ""
        echo "Device Control:"
        echo "  reset      - Reset the ESP32 device"
        echo "  cmd <cmd>  - Send command (e.g., '!CHIP_INFO', '!BOOTLOADER')"
        echo ""
        echo "Flashing (handles pause/resume automatically):"
        echo "  preflight       - Check if ready to flash (run before flashing)"
        echo "  flash <dir>     - Flash ESP-IDF project (auto-detects chip, finds binaries)"
        echo "  flash <file>    - Flash single binary file"
        echo "  build-flash <dir> - Build ESP-IDF project and flash"
        echo "  erase           - Erase entire flash"
        echo "  chip-info       - Get chip ID and flash info"
        echo "  read-mac        - Read MAC address"
        echo ""
        echo "Backup/Restore:"
        echo "  backup [file] [size] - Backup flash to file (default 4MB)"
        echo "  restore <file>  - Restore flash from backup"
        echo ""
        echo "Serial Communication:"
        echo "  send <text>     - Send text to device (e.g., 'r' to record)"
        echo "  monitor         - Live serial output (Ctrl+C to exit)"
        echo ""
        echo "Log Viewing:"
        echo "  tail [N] [--json]   - Show last N lines from serial log (default 50)"
        echo "  alerts [N] [--json] - Show last N alert lines (default 20)"
        echo "  wait <pat> - Wait for log line matching pattern"
        echo "  capture-between <start> <end> <out> [--decode-base64] [--json]"
        echo ""
        echo "Session files are in /tmp/eab-session/"
        ;;
esac
