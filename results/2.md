# Task Completion: nRF5340 APPROTECT Safety Guards and Erase Warnings

## Summary

Successfully implemented APPROTECT safety guards and erase warnings for nRF5340 to prevent accidental bricking of the debug session when erasing the NET core. The implementation includes automatic APPROTECT detection and recovery during flash operations.

## Changes Made

### 1. Modified `eab/chips/zephyr.py`

#### Added `check_approtect()` Method
- Reads APPROTECT status from UICR register (0x00FF8000) using `nrfjprog --memrd`
- Returns dict with `enabled`, `status`, `raw_value`, and `error` fields
- Supports both APP and NET cores via `--coprocessor` flag
- Handles various error conditions (timeout, nrfjprog not found, readback protection active)
- Parses nrfjprog output to extract hex value and determine if APPROTECT is enabled
- APPROTECT is disabled when value is 0xFFFFFF00, enabled for any other value

#### Enhanced `get_erase_command()` Method
- Added `core` parameter (choices: "app", "net", default: "app")
- Raises `RuntimeError` when attempting to erase nRF5340 NET core
- Error message explains APPROTECT re-enabling risk and recommends using `west flash` with `loadfile`
- APP core erase remains functional with `nrfjprog --recover`
- No restrictions on non-5340 nRF variants

### 2. Modified `eab/cli/__init__.py`

#### Added `--core` Argument to Erase Subparser
- Choices: "app", "net"
- Default: "app"
- Help text explains usage for multi-core chips (nRF5340)
- Passed through to `cmd_erase()` function

### 3. Modified `eab/cli/flash_cmds.py`

#### Enhanced `cmd_erase()` Function
- Added `core` parameter with default value "app"
- Passes `core` to `profile.get_erase_command()`
- Catches `RuntimeError` from blocked erase operations and returns proper error JSON
- Includes `core` field in output payload

#### Enhanced `cmd_flash()` Function
- Added automatic APPROTECT detection for nRF5340 chips before flashing
- Checks APP core APPROTECT status using `check_approtect()`
- If APPROTECT is enabled, automatically runs `nrfjprog --recover` to disable it
- Logs warning and recovery actions
- Returns error if recovery fails
- Continues with warning if APPROTECT status cannot be determined
- Adds `approtect_recovery_performed` flag to output payload

## Testing

### New Tests in `eab/tests/test_zephyr_profile.py`

All 10 new tests pass successfully:

1. **`test_erase_nrf5340_app_core_allowed`** - Verifies APP core erase is allowed
2. **`test_erase_nrf5340_net_core_blocked`** - Verifies NET core erase raises RuntimeError with proper message
3. **`test_erase_nrf52840_no_core_restriction`** - Verifies non-5340 nRF chips have no restrictions
4. **`test_check_approtect_disabled`** - Tests detection of disabled APPROTECT (0xFFFFFF00)
5. **`test_check_approtect_enabled`** - Tests detection of enabled APPROTECT (non-0xFFFFFF00)
6. **`test_check_approtect_readback_protection`** - Tests detection via readback protection error
7. **`test_check_approtect_net_core`** - Verifies --coprocessor flag is added for NET core
8. **`test_check_approtect_non_nrf_chip`** - Tests non-applicable response for non-nRF chips
9. **`test_check_approtect_nrfjprog_not_found`** - Tests handling of missing nrfjprog
10. **`test_check_approtect_timeout`** - Tests handling of command timeout
11. **`test_check_approtect_parse_error`** - Tests handling of unparseable output
12. **`test_erase_command_core_parameter_default`** - Tests default core parameter behavior

All existing tests (64 total) continue to pass.

## Key Implementation Details

### APPROTECT Detection Logic

The `check_approtect()` method uses `nrfjprog --memrd 0x00FF8000 --n 4` to read the UICR register that controls APPROTECT. The parsing logic:

1. First attempts to match "address: value" format: `0x00FF8000: FFFFFFFF`
2. Falls back to matching any 8-digit hex value if colon format not found
3. Checks if `(value & 0xFFFFFF00) == 0xFFFFFF00` to determine if APPROTECT is disabled
4. Handles error cases where nrfjprog fails due to readback protection being active

### NET Core Erase Protection

When attempting to erase nRF5340 NET core, the error message is:

```
CRITICAL: Cannot erase nRF5340 NET core - this re-enables APPROTECT, 
requiring ~30s recovery and potentially bricking the debug session. 
Use 'west flash' instead, which performs sector-erase via loadfile 
(safe and does not re-enable APPROTECT).
```

This prevents users from accidentally triggering APPROTECT re-enabling on the NET core.

### Auto-Recovery During Flash

When flashing to nRF5340, the flash command now:

1. Checks if APPROTECT is enabled on the APP core
2. If enabled, automatically runs `nrfjprog --recover` 
3. Logs the recovery action
4. Continues with the flash operation if recovery succeeds
5. Returns error if recovery fails or times out

This removes the manual step of detecting and recovering from APPROTECT, making the flash workflow more robust.

## Usage Examples

### Erase with Core Selection

```bash
# Erase APP core (safe, default)
eabctl erase --chip nrf5340

# Explicitly specify APP core
eabctl erase --chip nrf5340 --core app

# Attempt to erase NET core (blocked with error)
eabctl erase --chip nrf5340 --core net
# Returns error: "CRITICAL: Cannot erase nRF5340 NET core..."
```

### Automatic APPROTECT Recovery

```bash
# Flash will automatically detect and recover from APPROTECT
eabctl flash firmware.hex --chip nrf5340

# Output includes:
# {
#   "approtect_recovery_performed": true,
#   "success": true,
#   ...
# }
```

### Check APPROTECT Status (Python API)

```python
from eab.chips import get_chip_profile

profile = get_chip_profile("nrf5340")
status = profile.check_approtect(core="app")

print(f"APPROTECT enabled: {status['enabled']}")
print(f"Status: {status['status']}")
if status['raw_value']:
    print(f"UICR value: {status['raw_value']}")
```

## Backward Compatibility

All changes are backward compatible:

- Default `core` parameter is "app", matching previous behavior
- Existing erase commands continue to work without `--core` flag
- APPROTECT auto-recovery is automatic and doesn't require user intervention
- Non-nRF chips are unaffected by the new logic

## Files Modified

1. `eab/chips/zephyr.py` - Added APPROTECT checking and enhanced erase command
2. `eab/cli/__init__.py` - Added --core CLI argument
3. `eab/cli/flash_cmds.py` - Enhanced erase and flash commands with APPROTECT handling
4. `eab/tests/test_zephyr_profile.py` - Added 10 new comprehensive tests

## Verification

All tests pass:
```
============================== 64 passed in 0.03s ==============================
```

The implementation successfully prevents bricking scenarios while maintaining a smooth user experience through automatic recovery.
